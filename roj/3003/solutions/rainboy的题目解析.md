---
title: rainboy的解析
author: rainboy
date: "2023-12-20 11:08"
update: "2023-12-20 11:08"
home: https://github.com/rainboylvx
# 显示在rbook的练习中
practice_rbook: 
  - binary_state
top: true
---

## 解析


这里发现n只有20个,很小.

先上最简单的暴力思维: 枚举n个点的全排列,然后扫一遍得到结果.时间为$n \times n! = 20 \times 20 ! = 48658040163532800000$,显然超时. [[[rbook: ball_and_box]]]

进一步思考: 状态与集合

想像:在图上行走,某一个时刻可以把n个点分成两个集合: 1. 走过的点 2.没有走过的点.
如果现在还想向前走一步,那么还需要知道哪个点是集合1的终点.

于是结合[[[rbook: binary_state]]],设$f[i,j]$表示已经走过的点为i时,j是终点时的最小值.

$$
f(i,j) = min\{f(k,s) + w(s,j)\} \tag 1
$$

注意有限制条件:

1. 点j不在集合k里,也就是`(1<<j) & k == 0`
2. 点j与点s有连接:$w(s,j) != 0$
3. 状态$i = (1 << j) | k$
4. 起始状态为$f(1,0) = 0$

我们想求出的最终状态为`f((1<<n)-1,n-1)`


Q: 那么现在应该如何递推呢?也就是如果$a \to b$,求状态b时,保证状态a已经求出.

A: 状态按十进制大小从小到大枚举即可.证明: 根据式$(1)$,可知,$i > k$一定成立.所以$a< b$成立.


时间估算: 对于$f(i,j)$状态有$2^n \times n$,对于每一种状态,都需要扫描n个点进行判断,总时间为$2^n \times n^2 = 419430400 \approx = 4 \times 10^8$


## 代码

```cpp
<%- include("../std.cpp")%>
```
