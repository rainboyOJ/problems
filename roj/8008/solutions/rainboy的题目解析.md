---
title: rainboy的解析
author: rainboy
date: "2023-12-20 11:08"
update: "2023-12-20 11:08"
home: https://github.com/rainboylvx
top: true
---

## 解析

这个题目的最终解法不难,难的是思考得到这个最终解的过程,下面写一下我是什么得到这个最终解的.

1. 仔细读题目

这个很重要

第二段告诉我们: 一个基数为B的数,当B变大时,它对应的十进制数也会大.

看完题目后基数$B \in [2,15000]$,题目不能直接暴力枚举,会超时.



2. 先暴力

看这完题目后,好像想来不出来什么比暴力枚举方法更好方法啊?

根据我的做题目的经验,这个时候先写暴力,记住,想不出来是大部分是因为

- 没有数据让我们观察与思考,查找规律.
- 实践出真知


```cpp
<%- include("./baoli.cpp") _%>
```

一个显然的暴力程序就写好了,你可能会问,这肯定过不了啊!写这个有什么用?

### 2. 输出数据,找规律

一个简单的推论:

1. 题目的正解不是$n^2$,根据我们学过算法,没有学过$logn$的算法,所以正确解一定是$O(n)$
2. 也就是,从头扫一遍就出结果了
3. 那肯定符合某种规律!!
4. 规律是什么呢? 现在不知道,**我们需要观察数据!!!!!!**

有些同学习惯的拿出了纸,开始计算!!!!!!你有电脑为什么要用纸!!!!!

写出一个下面的代码



```cpp
<%- include("./check.cpp")%>
```

得到下面的数据

```
10:         419        792 
11:         504        948 
12:         597       1118 
13:         698       1302 
14:         807       1500 
15:         924       1712 
16:        1049       1938 
17:        1182       2178 
18:        1323       2432 
19:        1472       2700 
20:        1629       2982 
21:        1794       3278 
22:        1967       3588 
23:        2148       3912 
24:        2337       4250 
25:        2534       4602 
26:        2739       4968 
27:        2952       5348 
28:        3173       5742 
29:        3402       6150 
30:        3639       6572 
31:        3884       7008 
32:        4137       7458 
33:        4398       7922 
34:        4667       8400 
35:        4944       8892  <----
36:        5229       9398 
37:        5522       9918 
38:        5823      10452 
39:        6132      11000 
40:        6449      11562 
41:        6774      12138 
42:        7107      12728 
43:        7448      13332 
44:        7797      13950 
45:        8154      14582 
46:        8519      15228 
47:        8892      15888  <----
48:        9273      16562 
49:        9662      17250 
50:       10059      17952 
```


发现了吗?

1. 题目本质上不就是在两个数组上找相同的两个数吗?!!!!!(数学化归法)
2. 这个两数组是有序的,单调上升(啊!怪不得题目要花这么长的篇幅说基数变大的事!)
3. 题目答案是唯一的(题目说的),所以只有一对相同.




于是问题就变成(化归): 在两个严格升序的序列中查找一对唯一的一对相同数.

可以简单的想到第一组数为$419\;792$,因为$419 < 792$,且$419$必然小于现一列的后一个数(严格升序),所以$419$一定不可能和其它数相等,所以$419$不可能是答案.

我们用数学语言描述:设$A$,表示第一列的数字组合的有序集,同理$B$.则我们的问题表示为:$f(A,B)$,根据上面的推导,显然有

$$
f(A,B) = \left\{
\begin{array}{cl}
f(A- {a_1},B) & a_1 < b_1 \\
f(A, B- {b_1}) & a_1 < b_1 \\
a_1,b_1 a_1 == b_1
\end{array}
\right.
$$


这显然是一种递归!!!!,怎么表示$A$集合呢?,用数字,比如$10$,表示区间$[10,1500]$之间的数字.

得到代码如下

```cpp
<%- include("./dfs.cpp") _%>
```

因为,第i个数,只会被访问一遍,所以时间复杂度为$O(15000 \times 2)$,能过.

## 递推,归并排序思维


其实,如果你学过归并排序,你一下就会这个问题了! 思考方式类似归并排序!

因为这个两个有序序列只有一对数相同,那么我们把它们两个合并成一个有序序列后,显然这一对相同的数一定在一起.找到了这对相同的数,那就找到了答案.

具体操作,看代码


```cpp
<%- include("./merge.cpp") %>
```


## 对拍

暴力代码不是没有用的,他还可以对我们的完美代码进行检查.这个过程叫做对拍.

你自己不停的造两个数字,看两个程序的结果是否一样!!



## 最后

你得到了一个题目的经验: **任何在有序序列上查找信息的题目都有优化的方法**.
