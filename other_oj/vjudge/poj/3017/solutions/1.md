

题目大意:


给定一个长度为 N 的序列 A ，要求把该序列分成若干段，在满足“每段中所有数的和”不超过 M 的前提下，让“每段中所有数的最大值”之和最小。

因为分成每一段,类似于线性DP,考虑最后一段, 那就可以把问题转成一个线性DP问题

设$f(i)$表示前i个元素分成若干段,每段不超过和M, 且每段的最大值之和最小的方案数, 则有如下递推式:

设$max\_val(i,j) = \max_{k=i}^{j}\{a[k]\}$,也就是区间$[i,j]$之间的最值

$$
f(i) = \min_{j<i} \{ f[j] +  max\_val(j+1,i)\}
$$

注意$i,j$的之间的限制

1. $j<i$
2. $\sum_{j+1}^i{a[k]} \leqslant M$

- 这里显然需要用到前缀和来求区间和


这里先写出一个朴素的算法

```cpp
<%- include("./t1.cpp") %>
```

时间是$n^3$,如果使用倍增法RMQ求区间最值来优化`max_val`函数,那么时间变成$n^2$,n是$10^5$,所以会超时.

根据一般的做题目的方法: 肯定存在一个$O(n)$或$O(logn \cdot n)$的算法来优化朴素算法.

再根据做题目的经验,应该是基本是优化$j$为层循环.因为每一个状态$f[i]$都由多个连续的$f[j]$得到.

又可以观察到$f[i],f[i+1]$的决策区间,有重合,具体思考如下

1. 每一个i的都有一个决策区间$[j_i,i-1]$,显然这个$j_i$是使$pre\_sum(j_i+1,i) \leqslant m$成立的最左边的位置.
2. 对于$i+1$来说,$[j_{i+1},i]$是它的决策空间,那么根据数学计算$j_{i+1} \geqslant j_i$显然成立
3. 综上,可知,这不就是**决策区间重叠**,那不就是单调队列优化吗!!


但是对于$f[i]$来说,它不仅需要$f[j]$,还需要$max\_val(j+1,i)$的区间最值.这怎么办呢?

根据我一直讲的: **当我们不知道怎么做的时候,其实是我们没有数据**,那么我们继续使用神奇的观察法,来看看每个状态$f[i]$的决策点j的信息,列出下面的信息

每个状态$f[i]$

- 决策区间[j,i-1]
- 决策区间的数据
- 决策点j的位置,与值
- [j+1,i]之间的最值


在经过了数天的思考后,于2024-5-4是写下:

本质是去决策点的性质,**哪些点可能成为决策点**,也就是**排除**那些不是决策点的点,

```
------------- [ ----- ]
            j j+1     i
```

首先把已经知的条件写下来

1. f[i]是一个单调增的序列,因为所有的元素都是正值,增加一个元素后,一定会在f[i-1]的基础上加上一值,或在前面可以转移的点上增加一个值,也就是说$f[i] \geqslant f[j]$,j为可以转移点,证毕.
2. 决策点j与区间的起始点j+1,是相邻的两个元素

可以想到,若最后一个区间存在一个最值$A_k$,那么对于$j \leq j+1 \leqslant k$,设$\sum_{j_left}^i > M$,也就是说$j_left$是满足$\sum_{j_left+1}^i \leqslant M$最小的j,也就是最左边的j

那么答案就是$f[j] + A_k, (j_left\leqslant j < k)$,可以想像在j在这个取值范围内,取



## 题目点评
