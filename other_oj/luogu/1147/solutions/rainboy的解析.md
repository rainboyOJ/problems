---
title: "rainboy的解析"
date: "2024-02-09 11:08"
update: "2023-02-09 11:08"
author: rainboy
home:  https://github.com/rainboylvx
top: true
---

## 解析

先想到朴素的算法,二重循环,来查找,
因为到少有两个元素,那么就是


$$
n + (n-1) = M \\
2 \times n -1 = M
n = (M+1) \div 2
$$

```cpp
<%- include("./t1.cpp")%>
```

这个代码的时间复杂度为,$n^2$,也就是$(10^6)^2 = 10 ^12$ ,会超时

## 优化

查看输出数据,发现当第一数(起始位置)变大时,第二个数据也会变大.
这个很容易就可以想到,你自己想一下

```
18 142
297 328
388 412
1998 2002
```

于是我们可以写出下面的代码

当i固定时

- 要么可以找到对应的j,使得`range_sum(i,j) = M`
- 要么找不到对应的j,但你可以找到一个位置j,$range_sum(i,j) > M $成立

每一次$i$变成$i+1$时,j都要从上一次停止的位置向后查找,直到j超过了n停止整个算法.

```cpp
<%- include("./t2.cpp")%>
```

## 二分查找的代码

时间$nlogn$

```cpp
<%- include("./binary_search.cpp") _%>
```


