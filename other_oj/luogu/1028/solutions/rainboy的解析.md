---
title: "rainboy的解析"
date: "2024-02-09 11:08"
update: "2023-02-09 11:08"
author: rainboy
home:  https://github.com/rainboylvx
top: true
---

## 解析1

首先,仔细看样例说明

这是一个很简单的数字的除法问题: 一个数字$n$,它后面的数范围是$1,2,\cdots , \lfloor n/2 \rfloor$

小朋友法,他的问题是就是按题目分数字

画出一个这样的分解数的树

```
    6
   /|\
  1 2 3
    |  \
    1   1
```

发现树上的任意结点,都可以做为数列的结尾,于是树有多少个点,就是答案的数量.又因为递归就是在树上的行走,那么直接使用递归来做就行了,每进入一个新的递归函数,全局变量`ans`就加1


发现提交后代码超时,为什么呢? 因为$n \leqslant 10^3$,根据上式,具体计算了多少次,不好统计,

可以想到,转化成树后,第一层最大数为n,第二层最大数为$n/2$, 这样一共需要分$log_2^n$次,大约10层,因为$2^10 = 1024$,且每一层数远远超过2,取50,则$50^10 > 10^8$

其实不用那么麻烦,直接运行代码,输入最大数$1000$,发现代码直接不停,所以超时.使用$ctrl+c$强制停止.

优化代码,记忆化,比如计算$f(n)$


## 解析2

有一个小朋友,他的问题是$f(6)$:求6开头的数列的数量,于是他找到3个小朋友,分别求$f(1),f(2),f(3)$

因为6后面可以跟上以$1,2,3$开头的数列

那么显然

$$
f(6) = 1+f(1)+f(2)+f(3)
$$

显然$f(1) = 1$,作为边界

更一般的

$$
f(n) = 1 +  \sum_{i=1}^{\lfloor n/2 \rfloor } f(i)
$$

写出下面的初步代码

```cpp
<%- include("./rainboy.cpp")%>
```



