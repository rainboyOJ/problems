---
title: "rainboy的解析"
date: "2024-02-09 11:08"
update: "2023-02-09 11:08"
author: rainboy
home:  https://github.com/rainboylvx
top: true
---

## 解析

先写个枚举的暴力: 全组合,用于后面的验证


```cpp
<%- include("./baoli.cpp") _%>
```

## DP

思维过程:

1. 暴力(全组合)肯定超时(废话)
2. 套路: 看数据范围猜解
3. 可以看到$n,y< 10^8$,也就说最后只要扫一遍就能出结果,也就是线性的.
4. 


优化: 考虑到,如果数轴非常长,只有两个区间,距离很远,如$[1,3],[10^9,10^9+3]$,
这个问题只需要考虑这两个区间就可以了,数轴的长度不需要考虑,那么时间为$O(2)$,
推广开来,如果有n个点,那么也只需要考虑这n个区间,那么时间为$O(n)$
肯定存在一个代码,只关注区间就可以.
其实NOIP考过类似的题目,叫做摆渡车.
但是这个题目,上面的想法就可以过了,为了简单的实现代码,我就没有考虑那么复杂.

$f[i]$表示以位置i为结尾,前$i$个位置能得到的最大值,若位置$i$是某个区间的结尾

那么以$i$为结尾的区间a,要么选,要么不选

```math
f[i] = max \left\{
\begin{array}{lcr}
f[i-1] & & \text{不选以$i$为结尾的区间}\\
max(f[i],f[left(a_j)-1] + len(a_j)) & right(a_j) == i & \text{选一个以$i$为结尾的}
\end{array}
\right.
```

边界$f[-1] = 0$

- $left(a_j)$表示区间$a_j$的开头
- $right(a_j)$表示区间$a_j$的结尾
- $right(a_j) == i$表示区间$a_j$的结尾是$i$

```cpp
<%- include("./rainboy.cpp") _%>
```


